{
  "name": "Redux Real-World Example Project Teardown",
  "tagline": "",
  "body": "Here is a walk-through of the [Real-World example Redux project](https://github.com/reactjs/redux/tree/master/examples/real-world).\r\n\r\n## Project set up\r\n### Boilerplate\r\n\r\nAt the root of the project are the following \"boilerplate\" files that can be used in your own React-Redux projects in more-less the same form.\r\n\r\n#### ./package.json\r\n\r\n```json\r\n{\r\n  \"name\": \"redux-real-world-example\",\r\n  \"version\": \"0.0.0\",\r\n  \"description\": \"Redux real-world example\",\r\n  \"scripts\": {\r\n    \"start\": \"node server.js\"\r\n  },\r\n  \"repository\": {\r\n    \"type\": \"git\",\r\n    \"url\": \"https://github.com/reactjs/redux.git\"\r\n  },\r\n  \"license\": \"MIT\",\r\n  \"bugs\": {\r\n    \"url\": \"https://github.com/reactjs/redux/issues\"\r\n  },\r\n  \"homepage\": \"http://redux.js.org\",\r\n  \"dependencies\": {\r\n    \"babel-polyfill\": \"^6.3.14\",\r\n    \"humps\": \"^0.6.0\",\r\n    \"isomorphic-fetch\": \"^2.1.1\",\r\n    \"lodash\": \"^4.0.0\",\r\n    \"normalizr\": \"^2.0.0\",\r\n    \"react\": \"^0.14.7\",\r\n    \"react-dom\": \"^0.14.7\",\r\n    \"react-redux\": \"^4.2.1\",\r\n    \"react-router\": \"2.0.0\",\r\n    \"react-router-redux\": \"^4.0.0-rc.1\",\r\n    \"redux\": \"^3.2.1\",\r\n    \"redux-logger\": \"^2.4.0\",\r\n    \"redux-thunk\": \"^1.0.3\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"babel-core\": \"^6.3.15\",\r\n    \"babel-loader\": \"^6.2.0\",\r\n    \"babel-preset-es2015\": \"^6.3.13\",\r\n    \"babel-preset-react\": \"^6.3.13\",\r\n    \"babel-preset-react-hmre\": \"^1.1.1\",\r\n    \"concurrently\": \"^0.1.1\",\r\n    \"express\": \"^4.13.3\",\r\n    \"redux-devtools\": \"^3.1.0\",\r\n    \"redux-devtools-dock-monitor\": \"^1.0.1\",\r\n    \"redux-devtools-log-monitor\": \"^1.0.3\",\r\n    \"webpack\": \"^1.9.11\",\r\n    \"webpack-dev-middleware\": \"^1.2.0\",\r\n    \"webpack-hot-middleware\": \"^2.9.1\"\r\n  }\r\n}\r\n```\r\n\r\n#### ./.babelrc\r\n\r\n```\r\n{\r\n  \"presets\": [\"es2015\", \"react\"],\r\n  \"env\": {\r\n    \"development\": {\r\n      \"presets\": [\"react-hmre\"]\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n#### ./webpack.config.js\r\n\r\n```javascript\r\nvar path = require('path');\r\nvar webpack = require('webpack');\r\n\r\nmodule.exports = {\r\n  devtool: 'cheap-module-eval-source-map',\r\n  entry: [\r\n    'webpack-hot-middleware/client',\r\n    './index',\r\n  ],\r\n  output: {\r\n    path: path.join(__dirname, 'dist'),\r\n    filename: 'bundle.js',\r\n    publicPath: '/static/',\r\n  },\r\n  plugins: [\r\n    new webpack.optimize.OccurenceOrderPlugin(),\r\n    new webpack.HotModuleReplacementPlugin(),\r\n  ],\r\n  module: {\r\n    loaders: [\r\n      {\r\n        test: /\\.js$/,\r\n        loaders: ['babel'],\r\n        exclude: /node_modules/,\r\n        include: __dirname,\r\n      },\r\n    ],\r\n  },\r\n};\r\n```\r\n\r\n#### ./index.html\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html>\r\n  <head>\r\n    <title>Redux real-world example</title>\r\n  </head>\r\n  <body>\r\n    <div id=\"root\">\r\n    </div>\r\n    <script src=\"/static/bundle.js\"></script>\r\n  </body>\r\n</html>\r\n```\r\n\r\n#### ./index.js\r\n\r\n```javascript\r\nimport 'babel-polyfill';\r\nimport React from 'react';\r\nimport { render } from 'react-dom';\r\nimport { browserHistory } from 'react-router';\r\nimport { syncHistoryWithStore } from 'react-router-redux';\r\nimport Root from './containers/Root';\r\nimport configureStore from './store/configureStore';\r\n\r\nconst store = configureStore();\r\nconst history = syncHistoryWithStore(browserHistory, store);\r\n\r\nrender(\r\n  <Root store={store} history={history} />,\r\n  document.getElementById('root')\r\n);\r\n\r\n```\r\n\r\n#### server.js\r\n\r\n```javascript\r\nvar webpack = require('webpack');\r\nvar webpackDevMiddleware = require('webpack-dev-middleware');\r\nvar webpackHotMiddleware = require('webpack-hot-middleware');\r\nvar config = require('./webpack.config');\r\n\r\nvar app = new (require('express'))();\r\nvar port = 3000;\r\n\r\nvar compiler = webpack(config);\r\napp.use(webpackDevMiddleware(compiler, { noInfo: true, publicPath: config.output.publicPath }));\r\napp.use(webpackHotMiddleware(compiler));\r\n\r\napp.use(function (req, res) {\r\n  res.sendFile(__dirname + '/index.html');\r\n});\r\n\r\napp.listen(port, function (error) {\r\n  if (error) {\r\n    console.error(error);\r\n  } else {\r\n    console.info('==> ðŸŒŽ  Listening on port %s. Open up http://localhost:%s/ in your browser.',\r\n    port, port);\r\n  }\r\n});\r\n\r\n```\r\n\r\n#### routes.js\r\n\r\n```javascript\r\nimport React from 'react'\r\nimport { Route } from 'react-router'\r\nimport App from './containers/App'\r\nimport UserPage from './containers/UserPage'\r\nimport RepoPage from './containers/RepoPage'\r\n\r\nexport default (\r\n  <Route path=\"/\" component={App}>\r\n    <Route path=\"/:login/:name\"\r\n           component={RepoPage} />\r\n    <Route path=\"/:login\"\r\n           component={UserPage} />\r\n  </Route>\r\n)\r\n\r\n```\r\n\r\nYou'll see some project specific routes in routes.js.\r\n\r\n---\r\n\r\n### Directory Structure\r\n\r\n```\r\nreal-world/\r\n |---- actions/\r\n |---- components/\r\n |---- containers/\r\n |---- middleware/\r\n |---- reducers/\r\n |---- store/\r\n |---- .babelrc\r\n |---- index.html\r\n |---- index.js\r\n |---- package.json\r\n |---- routes.js\r\n |---- server.js\r\n |---- webpack.config.js\r\n\r\n```\r\n\r\n---\r\n\r\n### Accessing the Github API\r\n\r\nThe middleware directory is project specific, in this case, we'll be interacting with the Github API to query for users and get a list of repositories they follow.\r\n\r\n```\r\nreal-world/\r\n...\r\n|---- middleware/\r\n      |---- api.js\r\n...\r\n```\r\n\r\n#### api.js\r\n\r\n```javascript\r\nimport { Schema, arrayOf, normalize } from 'normalizr';\r\nimport { camelizeKeys } from 'humps';\r\nimport 'isomorphic-fetch';\r\n\r\n// Extracts the next page URL from Github API response.\r\nfunction getNextPageUrl(response) {\r\n  const link = response.headers.get('link');\r\n  if (!link) {\r\n    return null;\r\n  }\r\n\r\n  const nextLink = link.split(',').find(s => s.indexOf('rel=\"next\"') > -1);\r\n  if (!nextLink) {\r\n    return null;\r\n  }\r\n\r\n  return nextLink.split(';')[0].slice(1, -1);\r\n}\r\n\r\nconst API_ROOT = 'https://api.github.com/';\r\n\r\n// Fetches an API response and normalizes the result JSON according to the schema.\r\n// This makes every API response have the same shape, regardless of how nested it was.\r\nfunction callApi(endpoint, schema) {\r\n  const fullUrl = (endpoint.indexOf(API_ROOT) === -1) ? API_ROOT + endpoint : endpoint;\r\n\r\n  return fetch(fullUrl)\r\n    .then(response =>\r\n      response.json().then(json => ({ json, response }))\r\n    ).then(({ json, response }) => {\r\n      if (!response.ok) {\r\n        return Promise.reject(json);\r\n      }\r\n\r\n      const camelizedJson = camelizeKeys(json);\r\n      const nextPageUrl = getNextPageUrl(response);\r\n\r\n      return Object.assign({},\r\n        normalize(camelizedJson, schema),\r\n        { nextPageUrl }\r\n      );\r\n    });\r\n}\r\n\r\n// We use this Normalizr schemas to transform API responses from a nested form\r\n// to a flat form where repos and users are placed in `entities`, and nested\r\n// JSON objects are replaced with their IDs. This is very convenient for\r\n// consumption by reducers, because we can easily build a normalized tree\r\n// and keep it updated as we fetch more data.\r\n\r\n// Read more about Normalizr: https://github.com/gaearon/normalizr\r\n\r\n// GitHub's API may return results with uppercase letters while the query\r\n// doesn't contain any. For example, \"someuser\" could result in \"SomeUser\"\r\n// leading to a frozen UI as it wouldn't find \"someuser\" in the entities.\r\n// That's why we're forcing lower cases down there.\r\n\r\nconst userSchema = new Schema('users', {\r\n  idAttribute: user => user.login.toLowerCase(),\r\n});\r\n\r\nconst repoSchema = new Schema('repos', {\r\n  idAttribute: repo => repo.fullName.toLowerCase(),\r\n});\r\n\r\nrepoSchema.define({\r\n  owner: userSchema,\r\n});\r\n\r\n// Schemas for Github API responses.\r\nexport const Schemas = {\r\n  USER: userSchema,\r\n  USER_ARRAY: arrayOf(userSchema),\r\n  REPO: repoSchema,\r\n  REPO_ARRAY: arrayOf(repoSchema),\r\n};\r\n\r\n// Action key that carries API call info interpreted by this Redux middleware.\r\nexport const CALL_API = Symbol('Call API');\r\n\r\n// A Redux middleware that interprets actions with CALL_API info specified.\r\n// Performs the call and promises when such actions are dispatched.\r\nexport default store => next => action => {\r\n  const callAPI = action[CALL_API];\r\n  if (typeof callAPI === 'undefined') {\r\n    return next(action);\r\n  }\r\n\r\n  let { endpoint } = callAPI;\r\n  const { schema, types } = callAPI;\r\n\r\n  if (typeof endpoint === 'function') {\r\n    endpoint = endpoint(store.getState());\r\n  }\r\n\r\n  if (typeof endpoint !== 'string') {\r\n    throw new Error('Specify a string endpoint URL.');\r\n  }\r\n\r\n  if (!schema) {\r\n    throw new Error('Specify one of the exported Schemas.');\r\n  }\r\n\r\n  if (!Array.isArray(types) || types.length !== 3) {\r\n    throw new Error('Expected an array of three action types.');\r\n  }\r\n\r\n  if (!types.every(type => typeof type === 'string')) {\r\n    throw new Error('Expected action types to be strings.');\r\n  }\r\n\r\n  function actionWith(data) {\r\n    const finalAction = Object.assign({}, action, data);\r\n    delete finalAction[CALL_API];\r\n    return finalAction;\r\n  }\r\n\r\n  const [requestType, successType, failureType] = types;\r\n  next(actionWith({ type: requestType }));\r\n\r\n  return callApi(endpoint, schema).then(\r\n    response => next(actionWith({\r\n      response,\r\n      type: successType,\r\n    })),\r\n    error => next(actionWith({\r\n      type: failureType,\r\n      error: error.message || 'Something bad happened',\r\n    }))\r\n  );\r\n};\r\n\r\n```\r\n\r\n---\r\n\r\n### Configuring the store\r\n\r\nRedux uses a single \"Store\", here's how they set it up:\r\n\r\n```\r\nreal-world/\r\n...\r\n|---- reducers/\r\n|---- store/\r\n      |---- configureStore.js\r\n      |---- congifureStore.dev.js\r\n      |---- configureStore.prod.js\r\n...\r\n```\r\n\r\nThe configureStore.js file simply checks if the environment is labeled production, and if so requires the configureStore.prod.js configuration, otherwise it loads configureStore.dev.js. The primary difference between prod and dev is more logging and hot module replacement in dev.\r\n\r\n#### configureStore.js\r\n\r\n```javascript\r\nif (process.env.NODE_ENV === 'production') {\r\n  module.exports = require('./configureStore.prod')\r\n} else {\r\n  module.exports = require('./configureStore.dev')\r\n}\r\n```\r\n\r\n#### configureStore.dev.js\r\n\r\n```javascript\r\nimport { createStore, applyMiddleware, compose } from 'redux'\r\nimport thunk from 'redux-thunk'\r\nimport createLogger from 'redux-logger'\r\nimport api from '../middleware/api'\r\nimport rootReducer from '../reducers'\r\nimport DevTools from '../containers/DevTools'\r\n\r\nexport default function configureStore(initialState) {\r\n  const store = createStore(\r\n    rootReducer,\r\n    initialState,\r\n    compose(\r\n      applyMiddleware(thunk, api, createLogger()),\r\n      DevTools.instrument()\r\n    )\r\n  )\r\n\r\n  if (module.hot) {\r\n    // Enable Webpack hot module replacement for reducers\r\n    module.hot.accept('../reducers', () => {\r\n      const nextRootReducer = require('../reducers').default\r\n      store.replaceReducer(nextRootReducer)\r\n    })\r\n  }\r\n\r\n  return store\r\n}\r\n```\r\n\r\n#### configureStore.prod.js\r\n\r\n```javascript\r\nimport { createStore, applyMiddleware } from 'redux'\r\nimport thunk from 'redux-thunk'\r\nimport api from '../middleware/api'\r\nimport rootReducer from '../reducers'\r\n\r\nexport default function configureStore(initialState) {\r\n  return createStore(\r\n    rootReducer,\r\n    initialState,\r\n    applyMiddleware(thunk, api)\r\n  )\r\n}\r\n\r\n```\r\n\r\n---\r\n\r\n### Configuring the reducers\r\n\r\nIn Redux reducers handle events generated by actions to  update the application's state.\r\n\r\n```\r\nreal-world/\r\n...\r\n|---- reducers/\r\n      |---- index.js\r\n      |---- paginate.js\r\n...\r\n```\r\n\r\n#### index.js\r\n```javascript\r\nimport * as ActionTypes from '../actions';\r\nimport merge from 'lodash/merge';\r\nimport paginate from './paginate';\r\nimport { routerReducer as routing } from 'react-router-redux';\r\nimport { combineReducers } from 'redux';\r\n\r\n// Updates an entity cache in response to any action with response.entities.\r\nfunction entities(state = { users: {}, repos: {} }, action) {\r\n  if (action.response && action.response.entities) {\r\n    return merge({}, state, action.response.entities);\r\n  }\r\n\r\n  return state;\r\n}\r\n\r\n// Updates error message to notify about the failed fetches.\r\nfunction errorMessage(state = null, action) {\r\n  const { type, error } = action;\r\n\r\n  if (type === ActionTypes.RESET_ERROR_MESSAGE) {\r\n    return null;\r\n  } else if (error) {\r\n    return action.error;\r\n  }\r\n\r\n  return state;\r\n}\r\n\r\n// Updates the pagination data for different actions.\r\nconst pagination = combineReducers({\r\n  starredByUser: paginate({\r\n    mapActionToKey: action => action.login,\r\n    types: [\r\n      ActionTypes.STARRED_REQUEST,\r\n      ActionTypes.STARRED_SUCCESS,\r\n      ActionTypes.STARRED_FAILURE,\r\n    ],\r\n  }),\r\n  stargazersByRepo: paginate({\r\n    mapActionToKey: action => action.fullName,\r\n    types: [\r\n      ActionTypes.STARGAZERS_REQUEST,\r\n      ActionTypes.STARGAZERS_SUCCESS,\r\n      ActionTypes.STARGAZERS_FAILURE,\r\n    ],\r\n  }),\r\n});\r\n\r\nconst rootReducer = combineReducers({\r\n  entities,\r\n  pagination,\r\n  errorMessage,\r\n  routing,\r\n});\r\n\r\nexport default rootReducer;\r\n\r\n```\r\n\r\n#### paginate.js\r\n```javascript\r\nimport merge from 'lodash/merge';\r\nimport union from 'lodash/union';\r\n\r\n// Creates a reducer managing pagination, given the action types to handle,\r\n// and a function telling how to extract the key from an action.\r\nexport default function paginate({ types, mapActionToKey }) {\r\n  if (!Array.isArray(types) || types.length !== 3) {\r\n    throw new Error('Expected types to be an array of three elements.');\r\n  }\r\n\r\n  if (!types.every(t => typeof t === 'string')) {\r\n    throw new Error('Expected types to be strings.');\r\n  }\r\n\r\n  if (typeof mapActionToKey !== 'function') {\r\n    throw new Error('Expected mapActionToKey to be a function.');\r\n  }\r\n\r\n  const [requestType, successType, failureType] = types;\r\n\r\n  function updatePagination(state = {\r\n    isFetching: false,\r\n    nextPageUrl: undefined,\r\n    pageCount: 0,\r\n    ids: [],\r\n  }, action) {\r\n    switch (action.type) {\r\n      case requestType:\r\n        return merge({}, state, {\r\n          isFetching: true,\r\n        });\r\n      case successType:\r\n        return merge({}, state, {\r\n          isFetching: false,\r\n          ids: union(state.ids, action.response.result),\r\n          nextPageUrl: action.response.nextPageUrl,\r\n          pageCount: state.pageCount + 1,\r\n        });\r\n      case failureType:\r\n        return merge({}, state, {\r\n          isFetching: false,\r\n        });\r\n      default:\r\n        return state;\r\n    }\r\n  }\r\n\r\n  return function updatePaginationByKey(state = {}, action) {\r\n    switch (action.type) {\r\n      case requestType:\r\n      case successType:\r\n      case failureType:\r\n        const key = mapActionToKey(action);\r\n        if (typeof key !== 'string') {\r\n          throw new Error('Expected key to be a string.');\r\n        }\r\n\r\n        return merge({}, state, {\r\n          [key]: updatePagination(state[key], action);\r\n        });\r\n      default:\r\n        return state;\r\n    }\r\n  };\r\n}\r\n\r\n```\r\n\r\n---\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}